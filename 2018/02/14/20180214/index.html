<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>MySQL中的读锁和写锁 - rivers &amp; lakes</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/image/stef.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="/image/page_background.jpg"><div class="post-title"><h1 class="title">MySQL中的读锁和写锁</h1><ul class="meta"><li><i class="icon icon-author"></i>大米粥科技的小伙伴</li><li><i class="icon icon-clock"></i>3 Minutes</li><li><i class="icon icon-calendar"></i>February 14, 2018</li></ul></div></div><div class="article-content" style="max-width:800px"><p><br><font color="#ff0044" size="3.5" face="Times New Roman">MySQL中的读锁和写锁</font><br></p><br><font color="#000000" size="3.5" face="MV Boli">jiawei</font><br><a id="more"></a><br><br>数据的锁主要用来保证数据的一致性的，数据库的锁从锁定的粒度上可以分为表级锁、行级锁和页级锁。<br>读锁和写锁都是MySQL数据库的MyISAM引擎支持的表锁的。而对于行级锁的共享读锁和互斥写锁请阅读MySQL中的共享锁与排他锁。<br>在描述表锁的时候按照读写来区分，在表述行锁的时候按照共享和互斥来区分。<br>其实无论是表锁还是行锁。共享锁指的就是读锁！互斥锁、排他锁、独占锁值得都是写锁。<br><font color="#ff0044" size="3.5" face="Times New Roman">MyISAM表锁</font><br>MyISAM 存储引擎只支持表锁，MySQL 的表级锁有两种模式:表共享读锁(Table Read Lock)和表独占写锁(Table Write Lock)。<br>对于读操作，可以增加读锁，一旦数据表被加上读锁，其他请求可以对该表再次增加读锁，但是不能增加写锁。（当一个请求在读数据时，其他请求也可以读，但是不能写，因为一旦另外一个线程写了数据，就会导致当前线程读取到的数据不是最新的了。这就是不可重复读现象）<br>对于写操作，可以增加写锁，一旦数据表被加上写锁，其他请求无法在对该表增加读锁和写锁。（当一个请求在写数据时，其他请求不能执行任何操作，因为在当前事务提交之前，其他的请求无法看到本次修改的内容。这有可能产生脏读、不可重复读和幻读）。<br>读锁和写锁都是阻塞锁。<br>如果t1对数据表增加了写锁，这是t2请求对数据表增加写锁，这时候t2并不会直接返回，而是会一直处于阻塞状态，直到t1释放了对表的锁，这时t2便有可能加锁成功，获取到结果。<br><br><font color="#ff0044" size="3.5" face="Times New Roman">表锁的加锁/解锁方式</font><br>MyISAM 在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行更新操作 (UPDATE、DELETE、INSERT 等)前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。<br>如果用户想要显示的加锁可以使用以下命令：<br>锁定表：LOCK TABLES tbl_name {READ | WRITE},[ tbl_name {READ | WRITE},…]<br>解锁表：UNLOCK TABLES<br>在用 LOCK TABLES 给表显式加表锁时,必须同时取得所有涉及到表的锁。<br>在执行 LOCK TABLES 后，只能访问显式加锁的这些表，不能访问未加锁的表;<br>如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。<br>在自动加锁的情况下也基本如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁。这也正是 MyISAM 表不会出现死锁(Deadlock Free)的原因。<br>对表test_table增加读锁：<br>LOCK TABLES test_table READ<br>UNLOCK test_table<br>对表test_table增加写锁<br>LOCK TABLES test_table WRITE<br>UNLOCK test_table<br>当使用 LOCK TABLES 时,不仅需要一次锁定用到的所有表,而且,同一个表在 SQL 语句中出现多少次,就要通过与 SQL 语句中相同的别名锁定多少次,否则也会出错!<br>比如如下SQL语句：<br>select a.first_name,b.first_name, from actor a,actor b where a.first_name = b.first_name;<br>该Sql语句中，actor表以别名的方式出现了两次，分别是a,b，这时如果要在该Sql执行之前加锁就要使用以下Sql:<br>lock table actor as a read,actor as b read;<br><br><font color="#ff0044" size="3.5" face="Times New Roman">并发插入</font><br>MyISAM 表的读和写是串行的,但这是就总体而言的。在一定条件下,MyISAM表也支持查询和插入操作的并发进行。 MyISAM存储引擎有一个系统变量concurrent_insert,专门用以控制其并发插入的行为,其值分别可以为0、1或2。<br>当concurrent_insert设置为0时,不允许并发插入。<br>当concurrent_insert设置为1时,如果MyISAM表中没有空洞(即表的中间没有被删除的 行),MyISAM允许在一个进程读表的同时,另一个进程从表尾插入记录。这也是MySQL 的默认设置。<br>当concurrent_insert设置为2时,无论MyISAM表中有没有空洞,都允许在表尾并发插入记录。<br>可以利用MyISAM存储引擎的并发插入特性,来解决应用中对同一表查询和插入的锁争用。<br><br><font color="#ff0044" size="3.5" face="Times New Roman">MyISAM的锁调度</font><br>MyISAM 存储引擎的读锁和写锁是互斥的,读写操作是串行的。<br>一个进程请求某个 MyISAM 表的读锁,同时另一个进程也请求同一表的写锁,MySQL会写进程先获得锁。即使读请求先到锁等待队列,写请求后到,写锁也会插到读锁请求之前。<br>因为 MySQL 认为写请求一般比读请求要重要。<br>这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因,因为,大量的更新操作会造成查询操作很难获得读锁,从而可能永远阻塞。这种情况有时可能会变得非常糟糕!<br>可以通过 一些设置来调节 MyISAM 的调度行为。<br>通过指定启动参数low-priority-updates,使MyISAM引擎默认给予读请求以优先的权利。<br>通过执行命令SET LOWPRIORITYUPDATES=1,使该连接发出的更新请求优先级降低。<br>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性,降低该语句的优先级。<br>另外,MySQL也 供了一种折中的办法来调节读写冲突,即给系统参数max_write_lock_count 设置一个合适的值,当一个表的读锁达到这个值后,MySQL就暂时将写请求的优先级降低, 给读进程一定获得锁的机会。<br><br><p></p>
</div><div class="article-meta" style="max-width:800px"></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjlpvlrzw00024guc8qpvpdk8" data-title="MySQL中的读锁和写锁" data-url="http://yoursite.com/2018/02/14/20180214/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/03/03/20180303/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/02/03/20180203/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/stef24" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 rivers &amp; lakes<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>