<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>Map中的hash() - rivers &amp; lakes</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/image/stef.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="/image/page_background.jpg"><div class="post-title"><h1 class="title">Map中的hash()</h1><ul class="meta"><li><i class="icon icon-author"></i>大米粥科技的小伙伴</li><li><i class="icon icon-clock"></i>1 Minutes</li><li><i class="icon icon-calendar"></i>March 31, 2018</li></ul></div></div><div class="article-content" style="max-width:800px"><p><br><font color="#ff0044" size="3.5" face="Times New Roman">Map中的hash()</font><br></p><br><font color="#000000" size="3.5" face="MV Boli">jiawei</font><br><a id="more"></a><br><font color="#93C572" size="3.5" face="Times New Roman"><br>HashMap中hash方法的具体实现<br>HashTable、ConcurrentHashMap中hash方法的实现以及原因<br>为什么JDK 7和JDK 8中hash方法实现的不同以及区别<br></font><br><br><font color="#ff0044" size="3.5" face="Times New Roman">Hash</font><br>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。<br>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。<br>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。<br><br>常见的Hash函数有以下几个：<br>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。<br>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。<br>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。<br>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。<br>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。<br>伪随机数法：采用一个伪随机数当作哈希函数。<br><br>衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞.<br>常见的解决碰撞的方法有以下几种：<br>开放定址法<br>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。<br>链地址法<br>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。<br>再哈希法<br>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。<br>建立公共溢出区<br>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。<br><br><font color="#ff0044" size="3.5" face="Times New Roman">HashMap的数据结构</font><br>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。上面我们提到过，常用的哈希函数的冲突解决办法中有一种方法叫做链地址法，其实就是将数组和链表组合在一起，发挥了两者的优势，我们可以将其理解为链表的数组。<br>数组的每个成员是一个链表。该数据结构所容纳的所有元素均包含一个指针，用于元素间的链接。根据元素的自身特征把元素分配到不同的链表中去，反过来也正是通过这些特征找到正确的链表，再从链表中找出正确的元素。其中，根据元素特征计算元素数组下标的方法就是哈希算法。<br><br><p></p>
</div><div class="article-meta" style="max-width:800px"></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjlpvlrzw00054guc8ljtkbkc" data-title="Map中的hash()" data-url="http://yoursite.com/2018/03/31/20180331/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/04/14/20180414/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/03/17/20180317/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/stef24" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 rivers &amp; lakes<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>